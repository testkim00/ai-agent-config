# Orchestration

복잡한 작업을 체계적으로 수행하기 위한 오케스트레이션 명령어입니다.

## 사용법

```
/orchestration {대상}을 {작업}하세요
/orchestration {자연어 요청}
```

## 처리 흐름 (5단계)

```
┌─────────────────────────────────────────────────────────────────────┐
│ 1단계: 요청 분석 및 목표 설정                    ⏱️ 시간 기록 시작   │
│        ├ 1-1. 요청 내용/의도 파악                                   │
│        ├ 1-2. 필수 정보 간략 확인 (CLAUDE.md 등)                    │
│        ├ 1-3. 목표 설정 및 성공 기준 정의                           │
│        ├ 1-4. 목표 달성 계획안 작성                                 │
│        └ 1-5. 정보 수집 목록 작성                                   │
├─────────────────────────────────────────────────────────────────────┤
│ 2단계: 정보 수집                                 ⏱️ 각 호출별 기록   │
│        ├ 2-1. 프로젝트 전체 구조 수집                               │
│        ├ 2-2. 요청 항목 상세 수집                                   │
│        ├ 2-3. 파일별 import 문 수집 (raw data)                      │
│        ├ 2-4. 각 파일/폴더 역할 설명                                │
│        └ ⚡ 독립 항목 3개+ 시 Setter 병렬 실행                       │
├─────────────────────────────────────────────────────────────────────┤
│ 3단계: 정보 분석 및 상세 계획 수립               ⏱️ 분석 시간 기록   │
│        ├ 3-1. 수집 정보 분석                                       │
│        ├ 3-2. 포함/제외 목록 결정                                   │
│        ├ 3-3. ⭐ import 의존성 검증 (파일 복사/이동 시 필수)         │
│        │      ├ 포함 대상이 제외 대상을 import하는지 확인            │
│        │      └ 누락 발견 시 → 포함 목록 수정 또는 stub 생성         │
│        ├ 3-4. 추가 정보 필요 여부 판단 (→ 2단계 반복)               │
│        ├ 3-5. 상세 실행 계획 수립                                   │
│        └ 3-6. Advisor 계획 검토 (선택)                              │
├─────────────────────────────────────────────────────────────────────┤
│ 4단계: 실행                                      ⏱️ 각 작업별 기록   │
│        ├ 4-1. Supervisor에게 작업 분배                              │
│        ├ 4-2. Executor 실행 (병렬/순차)                             │
│        └ 4-3. 결과 검수 및 취합                                     │
├─────────────────────────────────────────────────────────────────────┤
│ 5단계: 실행 분석 보고                            📊 보고서 출력      │
│        ├ 5-1. 시간 기록 취합                                       │
│        ├ 5-2. 병목 단계 식별                                       │
│        ├ 5-3. 병목 원인 분석 (담당자 인터뷰 또는 직접 분석)          │
│        ├ 5-4. 보고서 생성 (콘솔 + JSON)                             │
│        └ 5-5. 개선 제안                                            │
└─────────────────────────────────────────────────────────────────────┘
```

**⚡ 실행 원칙: 단계 간 사용자 확인 없이 연속 진행**
- 타임스탬프만 기록하고 즉시 다음 단계로 진행
- 5단계 보고서 출력 후 종료

---

### 1단계: Orchestrator - 요청 분석 및 목표 설정

사용자 요청을 받으면 **Setter 호출 전에** 다음을 수행:

1. **요청 내용/의도 파악**
   - 사용자가 원하는 것이 무엇인지 명확히 정의

2. **필수 정보 간략 확인**
   - 프로젝트 구조 설명서 (CLAUDE.md, README.md 등)
   - 프로젝트의 대략적인 전체 구조 (`ls`, `tree` 등)

3. **목표 설정**
   - 달성해야 할 최종 목표 정의
   - 성공 기준 명시

4. **목표 달성 계획안 작성**
   - 대략적인 접근 방식 수립

5. **정보 수집 목록 작성**
   - Setter에게 전달할 구체적인 수집 항목 목록
   - **병렬 실행 고려**: 독립적인 항목끼리 그룹화
     ```
     예: [프로젝트 구조] [서비스 분석] [스토어 분석] → 3개 병렬
     ```

---

### 2단계: Setter - 정보 수집

> **핵심: 깊은 분석 없이 수집 + 역할 설명**

Task 도구로 Sonnet을 호출하여 **요청받은 목록의 정보 수집**:

- 프로젝트 전체 파일 구조 + **각 디렉토리/파일의 역할 설명**
- 프로젝트 개요 (있는 경우)
- 요청받은 정보 수집 목록의 상세 수집
- 관련 파일 경로 및 내용 + **기능/역할 설명**
- **파일별 import 문 수집** (raw data로 수집, 분석은 3단계에서)

> **주의:** 코드 패턴 분석, 통합 방안 검토, 포함/제외 판단 등 깊은 분석은 하지 않음.
> "이 파일/폴더가 무슨 역할인지" 설명은 필수.

#### ⚡ 병렬 실행 전략

수집 항목이 **3개 이상**이고 **서로 독립적**인 경우, 병렬로 Setter를 호출:

```
판단 기준:
├ 독립적: 서로 다른 폴더/모듈 조사 → 병렬 가능
├ 의존적: A 결과가 B 수집에 필요 → 순차 실행
└ 혼합: 독립 항목끼리 병렬, 의존 항목은 순차
```

**병렬 실행 예시:**
```python
# 수집 항목이 독립적인 경우 - 동시에 여러 Setter 호출
# 하나의 메시지에 여러 Task 호출을 포함

Task(
    subagent_type="Explore",
    prompt="프로젝트 전체 구조와 설정 파일 수집..."
)
Task(
    subagent_type="Explore",
    prompt="src/services/ 폴더의 서비스 파일들 수집..."
)
Task(
    subagent_type="Explore",
    prompt="src/stores/ 폴더의 스토어 파일들 수집..."
)
```

**분할 기준:**
| 항목 수 | 전략 |
|---------|------|
| 1~2개 | 단일 Setter |
| 3~5개 | 2~3개 Setter 병렬 |
| 6개+ | 주제별로 그룹화 후 병렬 |

```python
Task(
    subagent_type="Explore",
    model="sonnet",
    prompt="""
    [정보 수집 요청]

    다음 항목들을 수집하세요.
    각 파일/폴더가 어떤 기능과 역할을 하는지 간단히 설명을 달아주세요.
    (깊은 코드 분석은 하지 않음)

    [수집 목록]
    1. {Orchestrator가 작성한 수집 항목 1}
    2. {Orchestrator가 작성한 수집 항목 2}
    3. ...

    [출력 형식]
    ## 프로젝트 구조
    {디렉토리 트리}

    ### 주요 디렉토리 역할
    | 경로 | 역할 |
    |------|------|
    | src/api/ | API 엔드포인트 정의 |
    | src/models/ | 데이터 모델 정의 |

    ## 수집 항목 1: {항목명}
    - 경로: {파일 경로}
    - 역할: {이 파일이 하는 일}
    - 내용: {관련 코드/설정}

    ## 수집 항목 2: {항목명}
    ...

    ## 파일별 import 문 (raw data)
    (파일 복사/이동 작업인 경우 수집)

    | 파일 | import 경로 |
    |------|-------------|
    | boot/error-logger.js | @/utils/logs/logger.js |
    | boot/router-guards.js | @/_shared/core/stores/auth |
    | ... | ... |

    ## 기타 의존성
    - {파일A} → {파일B}: {참조 관계}
    """
)
```

---

### 3단계: Orchestrator - 정보 분석 및 상세 계획 수립

Setter 결과를 받아서 **분석 및 계획 수립**:

1. **수집된 정보 분석**
   - 코드 패턴 파악
   - 기존 구조와의 통합 방안 검토

2. **포함/제외 목록 결정**
   - 템플릿/복사 대상에 포함할 파일/폴더
   - 제외할 파일/폴더 (비즈니스 로직 등)

3. **⭐ import 의존성 검증** (파일 복사/이동 작업 시 필수)

   포함/제외 결정 후, Setter가 수집한 import 문을 분석:

   ```
   검증 로직:
   for each 포함_파일 in 포함_목록:
       for each import_경로 in 포함_파일.imports:
           if import_경로가 제외_목록에 있으면:
               ⚠️ 누락 의존성 경고!
   ```

   **출력 형식:**
   ```
   ## import 의존성 검증 결과

   ### ✅ 충족된 의존성
   | 포함 파일 | import 경로 | 상태 |
   |----------|-------------|------|
   | boot/router-guards.js | @/_shared/core/stores/auth | ✅ 포함됨 |

   ### ⚠️ 누락 의존성 경고
   | 포함 파일 | import 경로 | 상태 | 조치 |
   |----------|-------------|------|------|
   | boot/error-logger.js | @/utils/logs/logger.js | ❌ 제외됨 | 포함 추가 또는 stub 생성 |

   ### 조치 계획
   - `utils/logs/logger.js` → 포함 목록에 추가
   ```

   **누락 발견 시 선택지:**
   - A. 누락된 파일을 포함 목록에 추가
   - B. stub/mock 파일 생성
   - C. import하는 파일 수정 (해당 기능 제거)

4. **추가 정보 필요 여부 판단**
   - 부족하면 → Setter에 추가 수집 요청 (2단계 반복)
   - 충분하면 → 상세 계획 수립 진행

5. **상세 실행 계획 수립**
   - 작업 단계 분류
   - 의존성 순서 결정
   - 병렬 실행 가능 항목 식별
   - 예상 위험 요소 파악

---

### 4단계: Executor - 실행

계획에 따라 Sonnet으로 작업 실행:

- 독립 작업은 병렬 실행
- 의존성 있는 작업은 순차 실행
- 각 단계 완료 후 검증
- **각 작업 시작/종료 시간 기록**

#### 4-4. 빌드/실행 검증 (해당 시)

**프로젝트 생성/복사 작업인 경우 반드시 수행:**

```bash
# 예: Node.js 프로젝트
npm install && npm run build

# 예: Python 프로젝트
pip install -r requirements.txt && python -m pytest

# 예: Quasar 프로젝트
npm install && quasar build
```

**검증 실패 시:**
1. 에러 메시지 분석
2. 누락된 의존성 식별
3. 수정 후 재검증
4. 검증 통과 후에만 완료 처리

---

### 5단계: Analyzer - 실행 분석 보고

모든 실행 완료 후 **반드시** 수행:

#### 5-1. 시간 기록 취합
- 단계별 소요 시간
- Subagent 호출별 소요 시간
- 병렬 실행 그룹별 시간

#### 5-2. 병목 단계 식별
- 50% 이상: 🔴 심각한 병목
- 30~50%: 🟡 주의 필요
- 30% 미만: 🟢 정상

#### 5-3. 병목 원인 분석 ⭐

가장 오래 걸린 단계의 **담당자 인터뷰** 또는 **직접 분석**:

| 병목 단계 | 담당자 | 분석 방법 |
|----------|--------|----------|
| 1단계 | Orchestrator | 직접 분석 (왜 요청 분석이 오래 걸렸나) |
| 2단계 | Setter | Setter에게 인터뷰 (수집 범위, 파일 크기 등) |
| 3단계 | Orchestrator | 직접 분석 (추가 수집 횟수, 분석 복잡도) |
| 4단계 | Supervisor/Executor | 담당자 인터뷰 (작업 복잡도, 의존성 문제) |

**인터뷰 질문 예시:**
- "왜 이 작업이 예상보다 오래 걸렸나요?"
- "어떤 부분에서 지연이 발생했나요?"
- "다음에 개선할 수 있는 방법이 있나요?"

#### 5-4. 보고서 생성
- 콘솔 출력 (사람이 읽기 좋은 형식)
- JSON 파일 저장 (통계 분석용)

#### 5-5. 개선 제안
- 병목 원인에 기반한 구체적 개선안 제시

#### 보고서 저장 위치

```
~/.claude/orchestration/reports/{YYYY-MM-DD}_{HH-mm-ss}.json
```

#### 시간 기록 형식

```
[TIME] {단계}.{작업ID} | {START/END} | {timestamp} | {설명}
```

#### 보고서 출력 형식

```
═══════════════════════════════════════════════════════════════
                    실행 분석 보고서
═══════════════════════════════════════════════════════════════

■ 요약
┌─────────────────────────────────────────────────────────────┐
│ 총 실행 시간: {total_time}                                   │
│ 병목 단계: {bottleneck_stage}                                │
└─────────────────────────────────────────────────────────────┘

■ 위임 구조 요약
┌─────────────────────────────────────────────────────────────┐
│ Advisor 자문: {Yes/No} ({count}회)                           │
│ Setter 호출: {count}회 (추가 수집: {count}회)                 │
│ Supervisor 위임: {count}명                                   │
│ Executor 총 할당: {count}명                                  │
└─────────────────────────────────────────────────────────────┘

■ Supervisor별 Executor 할당
│ Supervisor A │ T1, T2 │ 3명 │ ✓ (병렬) │
│ Supervisor B │ T3, T4 │ 2명 │ ✓ (병렬) │

■ 단계별 소요 시간
┌──────────┬──────────────────────────────┬─────────┬─────────┐
│ 단계     │ 설명                         │ 소요    │ 비율    │
├──────────┼──────────────────────────────┼─────────┼─────────┤
│ 1단계    │ 요청 분석 및 목표 설정        │ {time}  │ {pct}%  │
│ 2단계    │ 정보 수집 (Setter)           │ {time}  │ {pct}%  │
│ 3단계    │ 분석 및 계획 수립            │ {time}  │ {pct}%  │
│ 4단계    │ 실행 (Executor)              │ {time}  │ {pct}%  │
└──────────┴──────────────────────────────┴─────────┴─────────┘

■ 병목 분석
┌─────────────────────────────────────────────────────────────┐
│ 🔴 주요 병목: {description}                                  │
│ 개선 제안: {suggestion}                                      │
└─────────────────────────────────────────────────────────────┘
═══════════════════════════════════════════════════════════════
```

---

## 예시

```
/orchestration 사용자 인증 기능을 추가하세요

→ [1단계: 요청 분석]
  - 의도: JWT 기반 사용자 인증 시스템 구축
  - 필수 확인: CLAUDE.md 읽기, 프로젝트 구조 확인
  - 목표: 로그인/로그아웃 API 및 인증 미들웨어 구현
  - 수집 목록:
    1. 기존 API 구조 (src/api/)
    2. 미들웨어 패턴 (src/middleware/)
    3. 사용자 모델 (src/models/user.*)

→ [2단계: 정보 수집] Setter 호출...
  ## 프로젝트 구조
  src/
  ├── api/
  │   └── base.ts
  ├── middleware/
  │   └── logger.ts
  └── models/
      └── user.ts

  ## 수집 항목 1: 기존 API 구조
  - 경로: src/api/base.ts
  - 내용: class BaseAPI { ... }

  ## 의존성
  - api/base.ts → models/user.ts

→ [3단계: 정보 분석 및 계획 수립]
  - 분석: BaseAPI 클래스 상속 패턴 사용
  - 추가 수집 필요: 없음
  - 상세 계획:
    1. 인증 모델 생성 (독립)
    2. API 엔드포인트 구현 (1 의존)
    3. 미들웨어 적용 (2 의존)
    4. 테스트 작성 (3 의존)

→ [4단계: 실행] Executor 호출...
  [TIME] 4.1 | START | 10:05:00 | Executor T1 시작
  [1/4] 인증 모델 생성 ✓
  [TIME] 4.1 | END   | 10:05:20 | Executor T1 완료 (20s)
  [2/4] API 엔드포인트 구현 ✓
  ...

→ [5단계: 분석 보고]
  ═══════════════════════════════════════════════════════════════
                      실행 분석 보고서
  ═══════════════════════════════════════════════════════════════
  ■ 요약
  │ 총 실행 시간: 3분 45초
  │ 병목 단계: 2단계 (정보 수집)

  ■ 위임 구조 요약
  │ Advisor 자문: No (0회)
  │ Setter 호출: 1회 (추가 수집: 0회)
  │ Supervisor 위임: 2명
  │ Executor 총 할당: 5명

  ■ Supervisor별 Executor 할당
  │ Supervisor A │ T1, T2       │ 2명 │ ✓ (병렬) │
  │ Supervisor B │ T3, T4       │ 3명 │ ✓ (병렬) │

  ■ 단계별 소요 시간
  │ 1단계 │ 요청 분석        │ 30s   │ 13%  │
  │ 2단계 │ 정보 수집        │ 95s   │ 42%  │ 🟡
  │ 3단계 │ 분석 및 계획     │ 40s   │ 18%  │
  │ 4단계 │ 실행             │ 60s   │ 27%  │

  ■ 병목 분석
  │ 🟡 주요 병목: 2단계 정보 수집 (42%)
  │ 개선 제안: 수집 범위를 좁히거나 캐싱 활용
  ═══════════════════════════════════════════════════════════════
```

## 참고

- 위임 체계: [instruction.md](~/.claude/skills/subagent-convention/instruction.md)
- 설정: [config.md](~/.claude/skills/subagent-convention/config.md)
