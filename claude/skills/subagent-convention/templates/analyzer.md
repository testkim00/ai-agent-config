# 실행분석관 (Execution Analyzer) 템플릿

오케스트레이션 실행 시간을 기록하고 병목을 분석하는 역할입니다.

## 모델 설정

| 항목 | 값 |
|------|-----|
| 모델 | Sonnet |
| subagent_type | general-purpose |

## 보고서 저장

### 저장 위치

```
~/.claude/orchestration/reports/
├── 2024-01-19_10-30-00.json
├── 2024-01-19_14-22-15.json
└── ...
```

### 파일명 형식

```
{YYYY-MM-DD}_{HH-mm-ss}.json
```

## 시간 기록

### 기록 시점

- 각 단계 시작/종료
- 각 subagent 호출 시작/종료
- 병렬 실행: 개별 시간 + 전체 시간

### 기록 형식

```
[TIME] {단계}.{작업ID} | {START/END} | {timestamp} | {설명}
```

예시:
```
[TIME] 1.0 | START | 2024-01-19 10:00:00 | 1단계: 요청 분석 시작
[TIME] 1.0 | END   | 2024-01-19 10:00:30 | 1단계: 요청 분석 완료 (30s)
[TIME] 2.1 | START | 2024-01-19 10:00:30 | Setter 호출 시작
[TIME] 2.1 | END   | 2024-01-19 10:01:45 | Setter 호출 완료 (75s)
[TIME] 4.1 | START | 2024-01-19 10:03:00 | Executor T1 시작
[TIME] 4.2 | START | 2024-01-19 10:03:00 | Executor T2 시작 (병렬)
[TIME] 4.1 | END   | 2024-01-19 10:03:20 | Executor T1 완료 (20s)
[TIME] 4.2 | END   | 2024-01-19 10:03:45 | Executor T2 완료 (45s)
[TIME] 4.P | END   | 2024-01-19 10:03:45 | 병렬 그룹 완료 (45s, 최대값 기준)
```

## 병목 판단 기준

| 비율 | 판정 |
|------|------|
| 50% 이상 | 🔴 심각한 병목 |
| 30~50% | 🟡 주의 필요 |
| 30% 미만 | 🟢 정상 |

### 일반적인 병목 원인

| 단계 | 원인 |
|------|------|
| 2단계 (Setter) | 파일 탐색 범위 과다, 대용량 파일 읽기 |
| 3단계 (분석) | 복잡한 의존성, 추가 수집 반복 |
| 4단계 (실행) | 순차 의존성 과다, 파일 수정 충돌 |

## 병렬 실행 효율성 분석 ⭐ 필수

### 효율성 지표

```
병렬 효율성 = (순차 실행 시 예상 시간) / (실제 병렬 실행 시간)
```

| 효율성 | 판정 |
|--------|------|
| 2.0x 이상 | 🟢 우수 (병렬화 효과 높음) |
| 1.5x ~ 2.0x | 🟡 양호 (개선 여지 있음) |
| 1.5x 미만 | 🔴 미흡 (병렬화 재검토 필요) |

### 분석 항목

1. **병렬 그룹별 효율성**
   - 각 병렬 그룹의 작업 수, 최소/최대/실제 시간
   - 작업 간 시간 편차 (편차가 크면 비효율)

2. **병렬화 기회 손실**
   - 순차로 실행했지만 병렬 가능했던 작업 식별
   - 의존성 오판으로 인한 불필요한 순차 실행

3. **병렬화 개선 제안**
   - 더 세분화할 수 있는 작업
   - 의존성 제거 가능한 작업

## 프로세스 개선 논의 ⭐ 필수

### 논의 대상

실행분석관은 Orchestrator와 다음 항목에 대해 논의합니다:

1. **계획 단계 검토**
   - 목표 설정이 명확했는가?
   - 정보 수집 항목이 적절했는가?
   - 작업 분할이 효율적이었는가?

2. **실행 단계 검토**
   - 병렬화 전략이 최적이었는가?
   - 예상치 못한 의존성이 있었는가?
   - 재작업이 발생했는가?

3. **전반적 프로세스**
   - 단계 간 정보 전달이 원활했는가?
   - 불필요한 반복이 있었는가?

### 개선방안 도출

논의 결과 뚜렷한 개선방안이 있으면 사용자에게 제시:

```
■ 프로세스 개선 제안 (Orchestrator 논의 결과)
┌─────────────────────────────────────────────────────────────┐
│ 💡 다음 오케스트레이션에서 적용 가능한 개선방안:              │
│                                                             │
│ 1. [즉시 적용] {improvement_1}                              │
│    - 근거: {reason}                                         │
│    - 예상 효과: {expected_effect}                           │
│                                                             │
│ 2. [검토 필요] {improvement_2}                              │
│    - 근거: {reason}                                         │
│    - 주의사항: {caution}                                    │
└─────────────────────────────────────────────────────────────┘
```

### 개선방안 분류

| 분류 | 설명 |
|------|------|
| 즉시 적용 | 명확한 효과, 부작용 없음 |
| 검토 필요 | 효과 예상되나 검증 필요 |
| 장기 과제 | 구조적 변경 필요, 추후 검토 |

## JSON 보고서 스키마

```json
{
  "meta": {
    "id": "2024-01-19_10-30-00",
    "start_time": "2024-01-19T10:30:00",
    "end_time": "2024-01-19T10:33:45",
    "total_seconds": 225,
    "request_summary": "사용자 인증 기능 추가"
  },
  "delegation": {
    "advisor_used": false,
    "advisor_count": 0,
    "setter_count": 1,
    "setter_additional": 0,
    "supervisor_count": 2,
    "executor_total": 5
  },
  "stages": [
    { "stage": 1, "name": "요청 분석 및 목표 설정", "seconds": 30, "percent": 13.3 },
    { "stage": 2, "name": "정보 수집 (Setter)", "seconds": 95, "percent": 42.2 },
    { "stage": 3, "name": "분석 및 계획 수립", "seconds": 40, "percent": 17.8 },
    { "stage": 4, "name": "실행 (Executor)", "seconds": 60, "percent": 26.7 }
  ],
  "subagents": [
    { "id": "2.1", "type": "Setter", "model": "sonnet", "seconds": 95, "status": "success" },
    { "id": "4.S1", "type": "Supervisor", "model": "opus", "seconds": 35, "status": "success", "executors": ["4.1", "4.2"] },
    { "id": "4.1", "type": "Executor", "model": "sonnet", "seconds": 20, "status": "success", "task": "T1" }
  ],
  "parallel_groups": [
    { "name": "Supervisor 레벨", "count": 2, "min_seconds": 25, "max_seconds": 35, "actual_seconds": 35 },
    { "name": "Sup.A → Executor", "count": 2, "min_seconds": 15, "max_seconds": 20, "actual_seconds": 20 }
  ],
  "parallel_efficiency": {
    "sequential_estimate_seconds": 180,
    "actual_seconds": 60,
    "efficiency_ratio": 3.0,
    "rating": "excellent",
    "missed_opportunities": [
      "T3, T4는 병렬 가능했으나 순차 실행됨"
    ],
    "improvement_suggestions": [
      "의존성 재분석으로 T3, T4 병렬화 가능"
    ]
  },
  "process_review": {
    "planning_phase": {
      "goal_clarity": "good",
      "info_collection_adequacy": "good",
      "task_division_efficiency": "needs_improvement",
      "feedback": "작업 분할을 더 세분화하면 병렬화 효율 증가"
    },
    "execution_phase": {
      "parallel_strategy": "good",
      "unexpected_dependencies": false,
      "rework_occurred": false,
      "feedback": "실행 단계는 원활했음"
    },
    "improvements": [
      {
        "priority": "immediate",
        "description": "Setter 병렬 호출로 정보 수집 시간 단축",
        "reason": "수집 항목이 독립적이었음",
        "expected_effect": "2단계 시간 50% 감소"
      },
      {
        "priority": "review_needed",
        "description": "작업 분할 기준 재정립",
        "reason": "일부 작업이 너무 커서 병렬화 효과 감소",
        "caution": "분할이 과도하면 오버헤드 증가"
      }
    ]
  },
  "bottleneck": {
    "stage": 2,
    "name": "정보 수집 (Setter)",
    "percent": 42.2,
    "severity": "warning",
    "analysis_method": "interview",
    "interviewee": "Setter",
    "interview": {
      "question": "왜 이 작업이 예상보다 오래 걸렸나요?",
      "answer": "프로젝트 구조가 복잡하고 파일 수가 많아 전체 탐색에 시간이 소요됨"
    },
    "causes": ["파일 탐색 범위 과다", "대용량 파일 읽기"],
    "suggestions": ["수집 범위를 좁히거나 캐싱 활용", "필요한 파일만 선별 수집"]
  }
}
```

## 콘솔 보고서 템플릿

```
═══════════════════════════════════════════════════════════════
                    실행 분석 보고서
═══════════════════════════════════════════════════════════════

■ 요약
┌─────────────────────────────────────────────────────────────┐
│ 총 실행 시간: {total_time}                                   │
│ 시작: {start_time}  종료: {end_time}                         │
│ 병목 단계: {bottleneck_stage}                                │
└─────────────────────────────────────────────────────────────┘

■ 위임 구조
┌─────────────────────────────────────────────────────────────┐
│ Advisor: {Yes/No} ({count}회)  Setter: {count}회            │
│ Supervisor: {count}명  Executor: {count}명                  │
└─────────────────────────────────────────────────────────────┘

■ Supervisor별 Executor 할당
┌──────────────────┬──────────────┬──────────────┬────────────┐
│ Supervisor       │ 담당 작업    │ Executor 수  │ 병렬 실행  │
├──────────────────┼──────────────┼──────────────┼────────────┤
│ Supervisor A     │ T1, T2       │ 3명          │ ✓          │
│ Supervisor B     │ T3, T4       │ 2명          │ ✓          │
└──────────────────┴──────────────┴──────────────┴────────────┘

■ 단계별 소요 시간
┌──────────┬──────────────────────────────┬─────────┬─────────┐
│ 단계     │ 설명                         │ 소요    │ 비율    │
├──────────┼──────────────────────────────┼─────────┼─────────┤
│ 1단계    │ 요청 분석 및 목표 설정        │ {time}  │ {pct}%  │
│ 2단계    │ 정보 수집 (Setter)           │ {time}  │ {pct}%  │
│ 3단계    │ 분석 및 계획 수립            │ {time}  │ {pct}%  │
│ 4단계    │ 실행 (Executor)              │ {time}  │ {pct}%  │
└──────────┴──────────────────────────────┴─────────┴─────────┘

■ Subagent 호출 상세
┌──────────┬──────────────────┬─────────┬──────────┬──────────┐
│ 호출 ID  │ 유형             │ 모델    │ 소요     │ 상태     │
├──────────┼──────────────────┼─────────┼──────────┼──────────┤
│ 2.1      │ Setter           │ sonnet  │ {time}   │ ✓        │
│ 4.S1     │ Supervisor A     │ opus    │ {time}   │ ✓        │
│ 4.1      │ Executor T1      │ sonnet  │ {time}   │ ✓        │
└──────────┴──────────────────┴─────────┴──────────┴──────────┘

■ 병렬 실행 분석
┌──────────────────┬──────────┬──────────┬──────────┬──────────┐
│ 그룹             │ 작업 수  │ 최소     │ 최대     │ 실제     │
├──────────────────┼──────────┼──────────┼──────────┼──────────┤
│ Supervisor 레벨  │ 2        │ {min}    │ {max}    │ {actual} │
│ Sup.A → Executor │ 3        │ {min}    │ {max}    │ {actual} │
└──────────────────┴──────────┴──────────┴──────────┴──────────┘
* 실제 = 병렬 실행 시 최대값 기준

■ 병목 분석
┌─────────────────────────────────────────────────────────────┐
│ 🔴 주요 병목: {bottleneck_description}                       │
│ 분석 방법: {interview/direct} - 담당자: {interviewee}        │
├─────────────────────────────────────────────────────────────┤
│ Q: 왜 이 작업이 예상보다 오래 걸렸나요?                        │
│ A: {answer}                                                 │
├─────────────────────────────────────────────────────────────┤
│ 원인: {causes}                                              │
│ 개선: {suggestions}                                         │
└─────────────────────────────────────────────────────────────┘

■ 타임라인
{start} ─────────────────────────────────────────────── {end}
├─[1단계]────────┤
│                ├─[2단계]─────────────────┤
│                │                         ├─[3단계]───┤
│                │                         │           ├─[4단계]──────┤
═══════════════════════════════════════════════════════════════
```

## 사용 방법

### Orchestrator 시간 기록

```python
# 시작 시
print(f"[TIME] {stage}.{task_id} | START | {datetime.now()} | {description}")

# 종료 시
print(f"[TIME] {stage}.{task_id} | END | {datetime.now()} | {description} ({elapsed}s)")
```

### 보고서 생성 시점

모든 실행 완료 후, Orchestrator가 수집된 시간 기록을 바탕으로 Analyzer 호출
